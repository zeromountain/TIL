# 소수잦기 level1

## 문제 설명

1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요.

소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.
(1은 소수가 아닙니다.)

## 제한조건

- n은 2이상 1,000,000 이하의 자연수입니다.

## 입출력 예

|  n  | result |
| :-: | :----: |
| 10  |   4    |
|  5  |   3    |

## 입출력 예 설명

### 입출력 예 # 1

- 1부터 10사이의 소수는 [2, 3, 5, 7] 4개가 존재하므로 4를 반환합니다.

### 입출력 예 # 2

- 1부터 5사이의 소수는 [2, 3, 5] 3개가 존재하므로 3을 반환합니다.

## 문제접근

- 소수란 1과 자기 자신만이 약수인 수를 말한다.
  - n이라는 수가 주어졌을 때, n까지 i가 2부터 1씩 증가하면서 n이 나누어 떨어지는 수는 소수에서 제외가된다.
  - 이 방법으로 문제를 접근했을 때, 조건에 n이 백만 이하의 수까지 주어졌기 때문에 실행 시간이 초과되었다.
- 에라토스테네스의 체
  - 에라토스테네스의 체는 소수를 찾는 방법이다. 고대 그리스 수학자 에라토스테네스가 발견하였다.
- 에라토스테네스의 체 알고리즘
  - 2부터 소수를 구하고자 하는 구간의 모든 수를 나열한다.
  - 2는 소수이다
  - n을 제외한 2의 배수를 모두 지운다.
  - 남아있는 수 가운데 3은 소수이다,
  - 자기 자신을 제외한 3의 배수를 모두 지운다.
  - 남아있는 수 가운데 5는 소수이다.
  - 자기 자신을 제외한 5의 배수를 모두 지운다.
  - 남아있는 수 가운데 7은 소수이다.
  - 자기 자신을 제외한 7의 배수를 모두 지운다.

위의 과정을 반복하면 구하는 구간의 모든 소수가 남는다.

## 문제풀이

### 시간 초과 풀이

```js
function solution(n) {
  let count = 0;
  for (let i = 2; i <= n; i++) {
    if (isPrime(i)) count++;
  }
  return count;
}

function isPrime(num) {
  if (num == 1) return false;
  for (let i = 2; i <= parseInt(Math.sqrt(num)); i++) {
    if (num % i == 0) return false;
  }
  return true;
}
```

### 효율성 제고 풀이

```js
function solution(n) {
  /*	2부터 n까지 n-1개를 저장할 수 있는 배열 할당
		배열 참조 번호와 소수와 일치하도록 배열의 크기는
		n+1 길이만큼 할당(인덱스 번호 0과 1은 사용하지 않음)	
    배열초기화: 처음엔 모두 소수로 보고 true값을 줌
    */
  let arr = new Array(n + 1).fill(1);
  arr[0] = arr[1] = 0;

  /*	에라토스테네스의 체에 맞게 소수를 구함
		만일, arr[i]가 true이면 i 이후의 i 배수는 약수로 i를 가지고 있는 것이 되므로 i 이후의 i 배수에 대해 false값을 준다.
		arr[i]가 false이면 i는 이미 소수가 아니므로 i의 배수 역시 소수가 아니게 된다. 그러므로 검사할 필요도 없다. 또한 i*k (k < i) 까지는 이미 검사되었으므로 j시작 값은 i**2 에서 i*i로 개선할 수 있다.
	*/

  for (let i = 2; i * i <= n; i++) {
    for (let j = i * 2; j <= n; j += i) {
      arr[j] = 0; // 소수가 아니면 0으로 바꾼다
    }
  }
  return arr.filter((item) => item === 1).length;
}
```
