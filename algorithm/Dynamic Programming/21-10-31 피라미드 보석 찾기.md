# 피라미드 보석 찾기

## 문제 설명

n층의 피라미드의 꼭대기에서 1층으로 내려와 탈출하려고 합니다.
피라미드에는 방이 있으며, n층에는 1개의 방이 존재하고, n-1 층에는 2개의 방, n-2 층에는 3개의 방이 1층에는 n개의 방이 존재합니다.
각 방은 왼쪽 아래와 오른쪽 아래의 방으로 이동하는 계단이 있고, 각 방에는 j개의 보석이 존재합니다.
n층의 피라미드 각 방에 존재하는 보석의 정보 arr이 주어질 때, 꼭대기 층에서 1층까지 내려오면서 모을 수 있는 보석의 최대 수를 구하는 함수, solution을 완성해주세요.

예를 들어, 3층의 피라미드의 각 방에 존재하는 보석의 정보 arr `[[3], [5, 10], [4, 8, 6]]`이 주어질 때, 피라미드를 탈출하며 모을 수 있는 보석의 최대 개수는 `3 + 10 + 8 = 21` 입니다.

             3
        5       10
    4       6       8

[제한 사항]

- 계단은 올라갈 수 없고, 내려갈 수만 있습니다.

[입력 형식]

- 피라미드의 층수 n은 1이상 100이하의 자연수입니다.
- 각 방의 보석 수 j는 1이상 1,000이하의 자연수입니다.

[출력 형식]

- 피라미드를 탈출하며 모을 수 있는 보석의 최대 수를 출력합니다.

[매개변수와 리턴타입]

- parameter → `number[][]`
- return → `number`

## 문제 접근

- 각 층마다 최대값을 합한다.
  - 최상층에서 최하층까지 최대 보석의 개수로 이동하는 경로는 최하층에서 최상층까지 최대 보석의 개수로 이동하는 경로와 같다.

## 문제 풀이

```js
function solution(arr) {
  const dp = [];
  let n = arr.length;
  for (let i = n - 1; i >= 0; i--) {
    dp[i] = [];

    for (let j = i; j >= 0; j--) {
      if (i === n - 1) {
        dp[i][j] = arr[i][j];
        continue;
      }

      dp[i][j] = arr[i][j] + Math.max(dp[i + 1][j], dp[i + 1][j + 1]);
    }
  }
  return dp[0][0];
}
```

- `input` 값으로 `[[3], [5, 10], [4, 8, 6]]`이 주어진 경우
- 바깥쪽 for 루프를 처음 수행할 때, `i`는 2이다.
  - `i`가 2일 때, `dp` 상태는 `[undefined, undefined, []]`이다.
  - 안쪽 for 루프의 `j`는 2부터 시작해 1씩 감소하며 0까지 반복한다.
    - 안쪽 for 루프를 수행하며 `dp[2]`에 4,8,6이 순서대로 들어간다.
  - 안쪽 for 루프를 종료하는 순간에 `dp`의 상태는 `[undefined, undefined, [4, 8, 6]]`이다.
- 다시 바깥쪽 for 루프를 수행할 때, `i`는 1이다.
  - `i`가 1일 때, `dp`의 상태는 `[undefined, [], [4, 8, 6]]`이다.
  - 안쪽 for 루프의 `j`는 1부터 시작해 0까지 반복한다.
    - `i`가 `n-1`이 아니기 때문에, if문 바깥의 `statement`를 수행한다.
      - dp[2]에서 최대값을 찾아서 arr[1]의 요소들과 더해준 값을 dp[1]에 저장한다.
    - `i`가 1인 경우 안쪽 for 루프를 수행한 후에 `dp`의 상태는 `[undefined, [13, 18], [4, 8, 6]`이다.
- 마지막 바깥쪽 for 루프를 수행할 때, `i`는 0이다.
  - `i`가 0일 때, `dp`의 상태는 `[[], [13, 18], [4, 8, 6]]`이다.
  - 안쪽 for 루프의 `j` 역시 0이다.
    - dp[0][0]에 dp[1]에서의 최대값과 arr[0]을 합한 값을 저장한다.
    - `i`가 0인 경우 안쪽 for 루프를 수행한 후에 `dp`의 상태는 `[[21], [13, 18], [4, 8, 6]]`이다.
- 전체 for 루프를 순회한 후에, `dp[0][0]`에 각 층의 최대값을 합한 보석의 최대 개수가 저장되는 것을 확인할 수 있다.
