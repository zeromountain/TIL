# 가장 많은 수 출력하기

## 문제 설명

0부터 9까지의 수가 최대 100,000개 입력됩니다. 이 때, 가장 많이 들어온 숫자 순서대로 출력하세요.

단, 들어온 횟수가 동일한 경우에는 작은 수를 먼저 출력합니다.

## 제한 사항

- 입력된 문자열의 길이

## 입력 형식

- 0부터 9까지의 수로 이루어진 자리수가 100,000 이하의 문자열이 들어옵니다.

## 출력 형식

- 가장 많이 들어온 숫자 순서대로 공백으로 구분하여 출력

## 입출력 예시

- str: 221123 → return: 2 1 3 0 4 5 6 7 8 9
- str: 1235670089006427894100 => 출력: 0 1 2 4 6 7 8 9 3 5

## 문제 접근

- 0부터 9까지의 수를 가장 많은 수를 정렬해야 하므로 0부터 9의 수를 배열에 담는다.
- 문자열로 주어진 숫자를 분석해(?) 0부터 9까지의 수를 요소로 갖는 배열을 정렬한다.

## 문제 풀이

```js
function solution(str) {
  let res = sorts(count(str));
  let ret = '';
  for (let i = 0; i < 10; i++) {
    ret += res[i] + ' ';
  }
  return ret;
}

const count = function (str) {
  // count → str의 요소의 개수를 카운트하는 함수
  let a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (let i = 0; i < str.length; i++) {
    a[str[i]]++;
  }
  return a;
};

let sorts = function (lists) {
  let order = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
  for (let i = 1; i < 10; i++) {
    for (let j = 0; j < i; j++) {
      if (lists[i] > lists[j]) {
        let temp = lists[i];
        lists[i] = lists[j];
        lists[j] = temp;

        temp = order[i];
        order[i] = order[j];
        order[j] = temp;
      } else if (lists[i] == lists[j] && order[i] < order[j]) {
        temp = order[i];
        order[i] = order[j];
        order[j] = temp;
      }
    }
  }
  return order;
};
```

- 인풋값으로 `101`이라는 문자가 주어졌다면
  - `count` 함수를 통해서 101의 요소를 카운트한다.
    - `a([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])`가 가지고 있는 배열은 각 인덱스 별로 0~9까지의 요소의 개수를 의미한다.
    - 101의 길이만큼 순회하며 문자열의 요소를 카운하면, a는 `[1, 2, 0, 0, 0, 0, 0, 0, 0, 0]`된다.
  - a는 `count` 함수에서 반환되어 `sorts` 함수에 전달된다.
    - `order`라는 변수는 0부터 9까지의 숫자를 배열에 담아놓고 `a` 의 카운트 개수를 참조해 정렬해 반환된다.
      - `a`의 0번 인덱스(1)와 1번 인덱스(2) 비교 → `order` 배열의 0과 1의 순서를 바꾼다
      - `a`의 0번 인덱스(2)와 2번 인덱스(0) 비교 → `order` 유지
      - `a`의 1번 인덱스(1)와 2번 인덱스(0) 비교 → `order` 유지
      - 이후의 `a`의 배열에서 카운트 0끼리의 비교이므로 오름차순 정렬된 상태이므로 그대로 반환한다.
        - `[1, 0, 2, 3, 4, 5, 6, 7, 8, 9]`가 `res` 변수에 담긴다
  - 배열인 `res`를 문자열로 반환하도록 문자열로 변환해주고 각 요소 사이를 공백으로 구분해준다.
