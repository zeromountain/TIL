# 퀵 정렬

병합정렬과 마찬가지로 특정한 값(`pivot`)을 기준으로 배열을 분할하여 정렬하는 알고리즘

## 동작 원리

다음과 같은 배열이 주어졌을 때, 퀵 정렬 알고리즘의 동작 방식을 살펴보겠다.

`[3, 1, 2, 7, 5, 6, 10, 4, 9, 8]`

- 1️⃣ 기준값을 정한다. `pivot` → 6
  - 기준값을 보통 배열의 마지막 요소로 설정하는 경우가 많지만 배열의 중간값으로 기준값을 설정하겠다.
    - 기준값을 배열의 양끝의 요소로 하는 경우 반복문을 사용하기가 수월하다.
- 2️⃣ 기준값을 기준으로 배열을 나눈다. (`작으면 → 왼쪽`, `크면 → 오른쪽`)
  - 3과 6 비교 → 3은 기준값 왼쪽 배열에 정렬
  - 1과 6 비교 → 1은 기준값 왼쪽 배열에 정렬
  - 2와 6 비교 → 2는 기준값 왼쪽 배열에 정렬
  - 7과 6 비교 → 7은 기준값 오른쪽 배열에 정렬
  - 5와 6 비교 → 5는 기준값 왼쪽 배열에 정렬
    - `[3, 1, 2, 5], [6], [7]`
  - 6과 10 비교 → 10은 기준값 오른쪽 배열에 정렬
  - 6과 4 비교 → 4는 기준값 왼쪽 배열에 정렬
  - 6과 9 비교 → 9는 기준값 오른쪽 배열에 정렬
  - 6과 8 비교 → 8은 기준값 오른쪽 배열에 정렬
    - `[3, 1, 2, 5, 4], [6], [7, 10, 9, 8]`
- 3️⃣ 왼쪽 배열과 오른쪽 배열도 기준값을 통해서 배열을 나누어 정렬한다.
  - 왼쪽 배열 `pivot` → 2
    - 3과 2 비교 → 3은 기준값 오른쪽 배열에 정렬
    - 1과 2 비교 → 1은 기준값 왼쪽 배열에 정렬
      - `[1], [2], [3]`
    - 2와 5 비교 → 5는 기준값 오른쪽 배열에 정렬
    - 2와 4 비교 → 4는 기준값 오른쪽 배열에 정렬
      - `[1], [2], [3, 5, 4]`
  - 오른쪽 배열 `pivot` → 9
    - 7과 9 비교 → 7은 기준값 왼쪽 배열에 정렬
    - 10과 9 비교 → 10은 기준값 오른쪽 배열에 정렬
      - `[], [9], [10]`
    - 9와 8 비교 → 8은 기준값 왼쪽 배열에 정렬
      - `[8], [9], [10]`
  - `[1], [2], [3, 5, 4],[6], [7, 8], [9], [10]`
- 4️⃣ 최소 단위로 나뉘지 않은 `[3, 5, 4]` 배열(`pivot` → 5)과 `[7, 8]` 배열(`pivot` → 8) 기준값을 기준으로 나눈다.
  - 3과 5 비교 → 3은 기준값 왼쪽 배열에 정렬
  - 4와 5 비교 → 4는 기준값 왼쪽 배열에 정렬
    - `[3, 4], [5]`
  - 7과 8 비교 → 7은 기준값 왼쪽 배열에 정렬
    - `[7], [8]`
  - `[1], [2], [3, 4], [5], [6], [7], [8], [9], [10]`
- 5️⃣ `[3, 4]` 배열을 기준값(`pivot` → 4)을 기준으로 나눈다.
  - 3과 4 비교 → 3은 기준값 왼쪽 배열에 정렬
    - `[3], [4]`
  - `[1], [2], [3], [4], [5], [6], [7], [8], [9], [10]
- 6️⃣ 나뉜 각각의 요소를 하나의 배열로 합친다.

## 시간복잡도

퀵 정렬의 시간복잡도는 병합정렬과 마찬가지로 O(NlogN)이며, 최악의 경우에는 O(N<sup>2</sup>)의 시간복잡도를 갖는다. 하지만, 최악의 경우의 시간복잡도가 발생하는 가능성이 현저하게 낮고 병합정렬보다 20% 이상의 성능의 우위를 보이기 때문에 가장 많이 사용되는 정렬 알고리즘으로 손꼽힌다.

## 구현

```js
function quickSort(arr) {
  if (arr.length <= 1) return arr;

  const mid = Math.floor(arr.length / 2);
  const pivot = arr[mid]; // 중간값을 기준값으로 설정

  const left = [];
  const right = [];

  for (let i = 0; i < arr.length; i++) {
    // 배열 전체를 순회
    if (arr[i] < pivot) {
      // 배열의 i 인덱스 요소가 pivot보다 작은 경우
      left.push(arr[i]); // left 배열에 push
    } else if (arr[i] === pivot) {
      // 배열의 i 인덱스 요소가 pivot과 같은 경우 → skip 한다
      continue;
    } else {
      // 배열의 i 인덱스 요소가 pivot보다 큰 경우
      right.push(arr[i]); // right 배열에 push
    }
  }

  return quickSort(left).concat(pivot, quickSort(right)); // 퀵정렬한 left 배열에 pivot과 퀵정렬한 right 배열을 concat 메서드로 합친다
}
```
