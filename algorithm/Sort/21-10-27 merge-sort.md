# 병합 정렬

- 배열을 최소 단위로 분할(divide)한 후에 병합(merge)하면서 정렬하는 알고리즘

## 동작 원리

다음과 같은 배열이 주어졌을 때, 병합 정렬 알고리즘의 동작 방식을 살펴보겠다.

`[1, 3, 5, 4, 8, 6, 7, 2]`

- 1️⃣ 위의 배열을 반으로 나눈다.
  - `[1, 3, 5, 4] , [8, 6, 7, 2]`
- 2️⃣ 1번에서 반으로 나눈 배열을 다시 반으로 나눈다.
  - `[1, 3] , [5, 4] , [8, 6] ,[7, 2]`
- 3️⃣ 2번에서 반으로 나눈 배열을 다시 반으로 나눈다.
  - `[1], [3], [5], [4], [8], [6], [7], [2]`
- 4️⃣ 더 이상 배열을 나눌 수 없으므로 병합하면서 정렬을 시작한다.(왼쪽 요소의 첫번째 요소와 오른쪽 요소의 첫번째 요소를 비교 → 더 작은 요소가 먼저 정렬된다)
  - 1과 3비교, 5와 4비교, 8과 6비교, 7과 2비교
    - `[1, 3], [4, 5], [6, 8], [2, 7]`
- 5️⃣ 첫번째 배열과 두번째 배열, 세번째 배열과 네번째 배열을 병합하며 정렬한다.
  - 1과 4비교 → 1 정렬
  - 3과 4비교 → 3 정렬
  - 4와5 정렬
    - `[1, 3, 4, 5]`
  - 6과 2비교 → 2 정렬
  - 6과 7비교 → 6 정렬
  - 8과 7 비교 → 7 정렬
  - 8 정렬
    - `[2, 6, 7, 8]`
  - `[1, 3, 4, 5], [2, 6, 7, 8]`
- 6️⃣ 첫번째 배열과 두번째 배열을 병합하며 정렬한다.
  - 1과 2 비교 → 1 정렬
  - 3과 2 비교 → 2 정렬
  - 3과 6 비교 → 3 정렬
  - 4와 6 비교 → 4 정렬
  - 5와 6 비교 → 5 정렬
  - 6, 7, 8 정렬
    - `[1, 2, 3, 4, 5, 6, 7, 8]`

## 시간복잡도

병합정렬의 시간복잡도는 최악의 경우와 최선의 경우 모두 O(NlogN)의 시간복잡도를 가지며, O(N<sup>2</sup>)의 시간복잡도를 갖는 버블정렬, 선택정렬, 삽입정렬보다는 성능이 높게 평가된다.

## 구현

```js
// 분할 부분
function divide(arr) {
  if (arr.length <= 1) return arr;
  const mid = Math.floor(arr.length / 2); // 배열의 중간값
  const left = arr.slice(0, mid); // 배열의 0번 인덱스부터 미드 전까지 요소 슬라이싱
  const right = arr.slice(mid); // 배열의 mid 이후 요소 슬라이싱
  return merge(divide(left), divide(right)); // divide를 재귀적으로 호출하면서 배열의 최소 단위(배열의 길이가 1)까지 나누고 병합하면서 올라온다.
}

// 정렬하고 병합하는 부분
function merge(left, right) {
  let sorted = [];

  while (left.length && right.length) {
    if (left[0] < right[0]) {
      // left 배열의 첫번째 요소가 right 배열의 첫번째 요소보다 작은 경우
      sorted.push(left.shift());
    } else {
      // right 배열의 첫번째 요소가 left 배열의 첫번째 요소보다 작은 경우
      sorted.push(right.shift());
    }
  }
  while (left.length) {
    // left 배열의 요소만 남은 경우
    sorted.push(left.shift()); // left 배열의 요소 첫번째 요소를 shift해서 sorted 배열에 push 한다.
  }
  while (right.length) {
    // right 배열의 요소만 남은 경우
    sorted.push(right.shift()); // right 배열의 요소 첫번째 요소를 shift해서 sorted 배열에 push 한다.
  }
  return sorted;
}
```
